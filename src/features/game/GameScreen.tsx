// src/features/game/GameScreen.tsx
import React, { useState, useEffect, useMemo, useCallback } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import { useGameStore } from '@/stores/useGameStore';
import { useLanguage } from '@/app/LanguageContext';
import { getEffectValue, calculateTotalPowerBonus } from '@/core/engine/effectSystem';
import useAI from '@/core/ai/useAI';
import { Player } from '@/types';
import { THEME } from '@/styles/theme';
import { useImagePreloader } from '@/hooks/useImagePreloader';
import { 
    MdMic
} from 'react-icons/md';

import { 
    GameHUD, GameField, GameHand, 
    LogsModal, StatsModal, InspectionModal, PauseModal, MatchResultModal, VisualEffectsLayer, LogMessage,
    DiscardPileModal, DeckPileModal
} from '@/features/game/components';

import { useGameInteraction } from '@/features/game/useGameInteraction';

const GameScreen: React.FC<{ onQuit: () => void }> = ({ onQuit }) => {
  const { t } = useLanguage();
  const { 
    gameState, 
    selectedAttackerId, 
    selectedBoostId, setSelectedBoostId,
    setDeckOpen, setDiscardOpen,
    handlePlayCard, handleAttack, handleBlock, resumeGame, handlePass,
    initMatch 
  } = useGameStore();

  const [showLogModal, setShowLogModal] = useState(false);
  const [showStatsModal, setShowStatsModal] = useState(false);
  const [showResultOverlay, setShowResultOverlay] = useState(false);
  const [showPauseMenu, setShowPauseMenu] = useState(false); 
  const [logsCopied, setLogsCopied] = useState(false);

  // URLs to preload
  const imageUrls = useMemo(() => {
    const urls: string[] = [
        'https://www.transparenttextures.com/patterns/grass.png',
        'https://www.transparenttextures.com/patterns/carbon-fibre.png'
    ];
    return urls;
  }, []);

  const isImagesLoaded = useImagePreloader(imageUrls);

  const { inspectedCard, setInspectedCard, onCardClick, inspectionActions, executeAction, onDragStart, onDropCard } = useGameInteraction(
      gameState, selectedBoostId, setSelectedBoostId, handlePlayCard, handleAttack, handleBlock
  );

  useAI();

  const isPlayerTurn = gameState?.turn === 'player';

  useEffect(() => {
    let timer: ReturnType<typeof setTimeout>;
    if (gameState?.winner) {
        timer = setTimeout(() => setShowResultOverlay(true), 1500);
    }
    return () => clearTimeout(timer);
  }, [gameState?.winner]);

  const copyLogs = useCallback(async () => {
    if (!gameState?.log) return;
    
    // FORMATAGE HARMONISÃ‰ AVEC LES SAUVEGARDES
    const reportHeader = `â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\n` +
                         `  âš½ MATCH REPORT: ${gameState.player.teamName.toUpperCase()} vs ${gameState.opponent.teamName.toUpperCase()}\n` +
                         `â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n` +
                         `ðŸ† Current Score: ${gameState.player.score} - ${gameState.opponent.score}\n` +
                         `----------------------------------------------\n\n`;

    const formattedLogs = gameState.log
      .map((l: any) => {
          const translatedParams = { ...l.params };
          if (l.params) {
              Object.keys(l.params).forEach(k => {
                  const val = l.params[k];
                  if (typeof val === 'string' && val.startsWith('logs.')) {
                      translatedParams[k] = t(val);
                  }
              });
          }
          let line = t(l.key, translatedParams);
          if (l.key.includes('ai_')) line = `[BOT LOG] ${line}`;
          return line;
      })
      .reverse()
      .join('\n');

    const techData = `\n\n----------------------------------------------\n` +
                     `ðŸ“Š ANALYTICS DATA\n` +
                     `Match ID: ${gameState.id}\n` +
                     `Remaining Deck (P/O): ${gameState.player.deck.length}/${gameState.opponent.deck.length}\n` +
                     `----------------------------------------------\n` +
                     `ðŸ End of Report - Generated by 1863 AI Engine âš½`;

    const finalReport = reportHeader + formattedLogs + techData;

    const textArea = document.createElement("textarea");
    textArea.value = finalReport;
    document.body.appendChild(textArea);
    textArea.select();
    
    try {
      if (document.execCommand('copy')) {
          setLogsCopied(true); 
          setTimeout(() => setLogsCopied(false), 2000); 
      }
    } catch (err) {
      console.error('Failed to copy logs', err);
    }
    document.body.removeChild(textArea);
  }, [gameState, t]);

  const handleRestart = () => {
      if (!gameState) return;
      const allPlayerCards = [...gameState.player.deck, ...gameState.player.hand, ...gameState.player.field, ...gameState.player.discard];
      const allOpponentCards = [...gameState.opponent.deck, ...gameState.opponent.hand, ...gameState.opponent.field, ...gameState.opponent.discard];
      
      initMatch(
          allOpponentCards.map(c => ({...c, instanceId: undefined, isFlipped: false, hasActed: false})),
          allPlayerCards.map(c => ({...c, instanceId: undefined, isFlipped: false, hasActed: false})),
          undefined, undefined,
          { player: gameState.player.teamName, opponent: gameState.opponent.teamName }
      );
      setShowPauseMenu(false);
      setShowResultOverlay(false);
  };

  const getVisualBonus = (card: Player, side: 'player' | 'opponent') => {
    if (!gameState || card.isFlipped) return 0;
    const phase = gameState.phase;
    let isAttackingSide = (phase === 'MAIN' && gameState.turn === side) || (phase === 'ATTACK_DECLARED' && gameState.turn !== side);
    let details = calculateTotalPowerBonus(gameState, card, side, isAttackingSide ? 'attacker' : 'defender');
    let total = details.bonus;
    if (side === 'player' && phase === 'ATTACK_DECLARED' && selectedBoostId) {
            const boostCard = gameState.player.hand.find(c => c.instanceId === selectedBoostId);
            if (boostCard) {
                total += getEffectValue(boostCard, 'value');
            }
    }
    return total;
  };
  
  const commentaryBox = useMemo(() => {
    if (!gameState?.log || gameState.log.length === 0) return null;
    const lastLog = gameState.log[0];
    const isTurnPlayer = gameState.turn === 'player';
    const activeColor = isTurnPlayer ? THEME.colors.player : THEME.colors.opponent;
    const bgColor = isTurnPlayer ? 'rgba(175, 255, 52, 0.15)' : 'rgba(239, 68, 68, 0.15)';
    
    return (
        <motion.div 
            key={lastLog.id} initial={{ y: 20, opacity: 0, scale: 0.95 }} animate={{ y: 0, opacity: 1, scale: 1 }} exit={{ y: -20, opacity: 0, scale: 0.95 }} 
            className="mx-auto w-fit max-w-[90%] flex items-center gap-3 px-5 py-2.5 rounded-full border border-white/10 backdrop-blur-xl shadow-[0_0_30px_rgba(0,0,0,0.5)] relative overflow-hidden group"
            style={{ backgroundColor: 'rgba(0, 0, 0, 0.85)', borderLeft: `4px solid ${activeColor}`, boxShadow: `inset 0 0 20px ${bgColor}` }}
        >
            <div className="absolute inset-0 opacity-10 pointer-events-none" style={{ backgroundColor: activeColor }} />
            <div className="flex items-center justify-center">
                <div className="w-8 h-8 rounded-full flex items-center justify-center bg-black/50 border border-white/5" style={{ color: activeColor }}>
                    <MdMic size={18} className="animate-pulse" />
                </div>
            </div>
            <div className="flex flex-col">
                <div className="flex items-center gap-2 mb-0.5">
                    <span className="text-[9px] font-black uppercase tracking-[0.2em]" style={{ color: activeColor }}>{t('game.live')}</span>
                    <span className="w-1 h-1 rounded-full bg-white/20" />
                    <span className="text-[9px] font-bold text-white/50 uppercase">{isTurnPlayer ? t('selection.you') : t('selection.opponent')}</span>
                </div>
                <div className="text-xs md:text-sm text-white font-semibold leading-snug tracking-tight">
                    <LogMessage logKey={lastLog.key} params={lastLog.params} />
                </div>
            </div>
        </motion.div>
    );
  }, [gameState?.log, gameState?.turn, t]);

  if (!gameState || !gameState.player || !gameState.opponent || !isImagesLoaded) {
    return (
        <div className="flex h-full flex-col items-center justify-center bg-[#0c0c0c] text-white">
            <div className="w-12 h-12 border-4 border-[#afff34]/20 border-t-[#afff34] rounded-full animate-spin mb-4"></div>
            <span className="text-[10px] font-black uppercase tracking-[0.3em] animate-pulse">{t('game.loading') || 'LOADING STADIUM...'}</span>
        </div>
    );
  }

  return (
    <div className="relative w-full h-full bg-[#0c0c0c] overflow-hidden flex flex-col font-sans text-white">
      <VisualEffectsLayer onResumeGame={resumeGame} />
      
      <div className="flex-1 relative grid grid-rows-6 gap-1 w-full max-w-[450px] mx-auto pb-2">
        <div className="absolute inset-0 z-0 opacity-50" style={{ background: `linear-gradient(to bottom, ${THEME.colors.grass.from}, ${THEME.colors.grass.via}, ${THEME.colors.grass.to})` }}>
            <div className="absolute inset-0 bg-[url('https://www.transparenttextures.com/patterns/grass.png')] opacity-20 contrast-125"></div>
        </div>
        <div className="absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 w-32 h-32 border-2 border-white/10 rounded-full z-0"></div>
        <div className="absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 w-2 h-2 bg-white/30 rounded-full z-0"></div>
        <div className="absolute inset-x-0 top-1/2 -translate-y-1/2 h-px bg-white/10 z-0"></div>

        <div className="relative z-10 flex items-center justify-center pt-4">
            <GameHUD onMenuClick={() => setShowPauseMenu(true)} />
        </div>

        <div className="relative z-10 flex items-center justify-center">
            <GameHand hand={gameState.opponent.hand} sideKey="opponent" selectedBoostId={null} deckCount={gameState.opponent.deck.length} discardCount={gameState.opponent.discard.length} onCardClick={onCardClick} />
        </div>

        <div className="relative z-10 flex items-center justify-center">
            <GameField field={gameState.opponent.field} sideKey="opponent" attackerInstanceId={gameState.attackerInstanceId || null} selectedAttackerId={selectedAttackerId} turn={gameState.turn} phase={gameState.phase} getVisualBonus={getVisualBonus} onCardClick={onCardClick} onDropCard={onDropCard} />
        </div>
            
        <div className="relative z-10 flex items-center justify-center">
            <GameField field={gameState.player.field} sideKey="player" attackerInstanceId={gameState.attackerInstanceId || null} selectedAttackerId={selectedAttackerId} turn={gameState.turn} phase={gameState.phase} isMeneurActive={gameState.meneurActive} getVisualBonus={getVisualBonus} onCardClick={onCardClick} onDropCard={onDropCard} />
        </div>
        
        <div className="relative z-10 flex items-center justify-center">
            <GameHand hand={gameState.player.hand} sideKey="player" selectedBoostId={selectedBoostId} deckCount={gameState.player.deck.length} discardCount={gameState.player.discard.length} onCardClick={onCardClick} onDragStart={onDragStart} onDeckClick={() => setDeckOpen(true)} onDiscardClick={() => setDiscardOpen(true)} />
        </div>

        <div className="relative z-20 flex items-center justify-center h-full">
             <div className="scale-100 w-full flex justify-center">
                <AnimatePresence mode="wait">{commentaryBox}</AnimatePresence>
             </div>
        </div>
      </div>
      
      <DiscardPileModal /> 
      <DeckPileModal />

      <AnimatePresence>
          {showLogModal && <LogsModal key="logs-modal" isOpen={showLogModal} onClose={() => setShowLogModal(false)} logs={gameState.log} copyLogs={copyLogs} logsCopied={logsCopied} />}
          {showStatsModal && <StatsModal key="stats-modal" isOpen={showStatsModal} onClose={() => setShowStatsModal(false)} player={gameState.player} opponent={gameState.opponent} goals={gameState.goals} />}
          {showPauseMenu && (
              <PauseModal key="pause-modal" isOpen={showPauseMenu} onResume={() => setShowPauseMenu(false)} onRestart={handleRestart} onQuit={onQuit} onShowLogs={() => { setShowPauseMenu(false); setShowLogModal(true); }} onShowStats={() => { setShowPauseMenu(false); setShowStatsModal(true); }} />
          )}
          {inspectedCard && (
              <InspectionModal key="inspect-modal" card={inspectedCard.card} side={inspectedCard.side} onClose={() => setInspectedCard(null)} actions={inspectionActions} onAction={executeAction} />
          )}
          {showResultOverlay && gameState.winner && (
              <MatchResultModal 
                key="result-modal" 
                winner={gameState.winner} 
                playerScore={gameState.player.score} 
                opponentScore={gameState.opponent.score} 
                playerTeamName={gameState.player.teamName} 
                opponentTeamName={gameState.opponent.teamName} 
                onRematch={handleRestart} 
                onMenu={onQuit} 
                onReview={() => setShowResultOverlay(false)} 
              />
          )}
      </AnimatePresence>
    </div>
  );
};

export default GameScreen;